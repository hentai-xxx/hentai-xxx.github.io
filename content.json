{"meta":{"title":"Eternity & Infinity","subtitle":null,"description":null,"author":"Eternity & Infinity","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Dijkstra Algorithm","slug":"Dijkstra-Algorithm","date":"2019-08-24T13:11:34.000Z","updated":"2019-08-25T01:14:27.258Z","comments":true,"path":"2019/08/24/Dijkstra-Algorithm/","link":"","permalink":"http://yoursite.com/2019/08/24/Dijkstra-Algorithm/","excerpt":"","text":"Induction:Dijkstra’s algorithm is an algorithm for finding the shortest paths betweennodes in a graph, which may represent, for example, road networks. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three yearslater. Dijkstra’s algorithmDijkstra’s algorithm finds a shortest path tree from a single source node, bybuilding a set of nodes that have minimum distance from the source. The graph has the following: vertices, or nodes, denoted in the algorithm by v or u; weighted edges that connect two nodes: (u, v) denotean edge, and w(u,v)denotes its weight. This is done by initializing three values: dist, an array of distances from the source node s to each node inthe graph, initialized the following way: dist(s) = 0; and for all other nodes v, dist(v) = ∞\\infty∞. This is done at the beginning becauseas the algorithm proceeds, the dist from the source to each node v inthe graph will be recalculated and finalized when the shortest distance tov is found. Q, a queue of all nodes in the graph. At the end of the algorithm’sprogress, Q will be empty. S, an empty set, to indicate which nodes the algorithm has visited.At the end of the algorithm’s run, S will contain all the nodes ofthe graph. The algorithm proceeds as follows: While Q is not empty, pop the node v, that is not already in S,from Q with the smallest dist(v). In the first run, source node swill be chosen because dist(s) was initialized to 0. In the next run,the next node with the smallest dist value is chosen. Add node v to S, to indicate that v has been visited. Update dist values of adjacent nodes of the current node v as follows:for each new adjacent node u, if dist(v) + weight(u,v) &lt; dist(u), there is a new minimal distancefound for u, so update dist(u) to the new minimal distance value; otherwise, no updates are made to dist(u). The algorithm has visited all nodes in the graph and found the smallest distanceto each node. distdistdist now contains the shortest path tree from source s. ==Note: The weight of an edge(u, v) is taken from the value associated with (u, v)on the graph.== Implmentation:This is pseudocode for Dijkstra’s algorithm, mirroring Python syntax. It can be used in order to implement the algorithm in any language. 123456789101112131415161718function Dijkstra(Graph, source): dist[source] := 0 // Distance from source to source is set to 0 for each vertex v in Graph: // Initializations if v ≠ source dist[v] := infinity // Unknown distance function from source to each node set to infinity add v to Q // All nodes initially in Q while Q is not empty: // The main loop v := vertex in Q with min dist[v] // In the first run-through, this vertex is the source node remove v from Q for each neighbor u of v: // where neighbor u has not yet been removed from Q. alt := dist[v] + length(v, u) if alt &lt; dist[u]: // A shorter path to u has been found dist[u] := alt // Update distance of u return dist[] end function This is the python code for the dijkstra algorithm.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import heapqclass Node(): \"\"\" Nodes in the graph. \"\"\" def __init__(self, number=0, weight=0): self.number = number self.weight = weight def __lt__(self, other): return self.weight &lt; other.weightdef dijkstra_heap(graph, start): \"\"\" Dijkstra algorithm for heap optimization. \"\"\" INF = 999999999 dist = [INF for node in graph] path = [-1 for node in graph] visited = [False for node in graph] dist[start] = 0 path[start] = start pq = list() heapq.heappush(pq, Node(start, 0)) while pq: temp = heapq.heappop(pq) here = temp.number cost = temp.weight if visited[here]: continue else: visited[here] = True for node in graph[here]: if (not visited[node]) and (cost + graph[here][node] &lt; dist[node]): dist[node] = cost + graph[here][node] path[node] = here heapq.heappush(pq, Node(node, dist[node])) display_path(graph, start, dist, path, visited)def display_path(graph, start, dist, path, visted): \"\"\" Print the shortest path. \"\"\" print(\"Path from \" + str(start) + \" node to other node :\") routes = list() for i in range(len(graph)): route = list() if visted[i] and i != start: route.append(i) temp = path[i] while temp != start: route.append(temp) temp = path[temp] route.append(start) routes.append(route) for route in routes: if route: temp = str() for node in reversed(route): temp += \"#\" + str(node) if route.index(node) != 0: temp += \" -&gt; \" print(\"#\" + str(start) + \" -&gt; \" + str(route[0]) + \" : \" + \"weight:\" + str(dist[route[0]]) + \"\\t\" + temp) elif routes.index(route) != start: print(\"#\" + str(start) + \" -&gt; \" + str(route[0]) + \" : \" + \"No Path!\")","categories":[],"tags":[{"name":"Graph Algorithm","slug":"Graph-Algorithm","permalink":"http://yoursite.com/tags/Graph-Algorithm/"}]},{"title":"My First Blog","slug":"My-First-Blog","date":"2019-08-23T09:21:26.000Z","updated":"2019-08-24T09:26:00.018Z","comments":true,"path":"2019/08/23/My-First-Blog/","link":"","permalink":"http://yoursite.com/2019/08/23/My-First-Blog/","excerpt":"","text":"然后就是二级标题聪明的如你肯定知道六级标题怎么写 记得我们说过换行的问题吗。不加 空行 的换行是不做数的。 加了 空行 就对了。 如果你用过 LATEX 的话应该是习惯这种写法的。 无序列表的符号除了*之外 用+/-也是可以的 但是混用不太好吧，还是统一比较好 我是习惯于用*的 嗯，手动的空格缩进就能带来列表缩进 加上数字编号就能做出有序列表 有序列表也不需要前面的数字完全按照顺序排列 这样更方便我们随便改变顺序对不对 这段会被认为是代码，或者纯文本。 反正不用担 心被格式处理。 print 3*5*7 一个表格的例子： 左对齐 居中 右对齐 2 3 5 10 100 1000 12345678910111213def lower_bound(array, key): \"\"\" Time complexity : O(logn). \"\"\" low = 0 high = len(array) - 1 while low &lt;= high: mid = (low + high) &gt;&gt; 1 if array[mid] &lt; key: low = mid + 1 else: high = mid - 1 return low 这段就是引用注意【引用】这个东西会被怎么表示可是不一定的，不同的显示环境处理起来往往大相径庭。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-08-23T07:54:37.791Z","updated":"2019-08-23T07:54:37.791Z","comments":true,"path":"2019/08/23/hello-world/","link":"","permalink":"http://yoursite.com/2019/08/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}